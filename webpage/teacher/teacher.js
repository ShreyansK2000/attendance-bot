init = () => {
    // Update Present Table, Unclaimed Table and 
    // All Registered Students table as the page is loaded
    requestPresent();
    requestUnclaimed();
    requestAll();
    // Set the intervals until forever
    setInterval(requestPresent, 3000);
    setInterval(requestUnclaimed, 3000);
    setInterval(requestAll, 20000);
    // Set up the socket stream from the raspberry pi, open it
    let uri = "ws://" + window.location.hostname + "/ws/client";
    try {
        sock = new WebSocket(uri);
    } catch (err) {
        // If the socket fails, we're on a secure page. Redirect to insecure
        // because we couldn't open wss socket
        window.location.href = "http://cpen291-16.ece.ubc.ca/teacher/";
    }
    // Notify when socket connects
    sock.addEventListener('open', (e) => {
        console.log("Opened")
    });
    // Add an event for when the socket messages us
    sock.addEventListener('message', (e) => {
        let camHolder = document.getElementById("camFeed");
        let ctx = camHolder.getContext("2d");
        let img = new Image();
        img.src = URL.createObjectURL(e.data);
        img.addEventListener('load', (e) => {
            ctx.drawImage(img, 0, 0, camHolder.width, camHolder.height);
        });
    });
}

requestNewDbEntry = () => {
    // No validation necessary for this function since we assume
    // the teacher is not malicious
    let xml = new XMLHttpRequest();
    xml.onreadystatechange = function() {
        if (this.status === 200 && this.readyState === 4) {
            // Success, print the secret to the status div
            document.getElementById("secretStatus").innerHTML = this.responseText;
        }
    }
    // Call our create_new_db_entry.php endpoint
    xml.open("POST", "create_new_db_entry.php");
    // We have to set the header since we don't have anything else controlling it
    xml.setRequestHeader("content-type", "application/x-www-form-urlencoded");
    // Send the payload with requestSecret
    xml.send("requestSecret=true");
}

requestSetNeedsUpdate = () => {
    // Checking for valid input just in case since this is manual input
    let inputVal = document.getElementById("stuIDInput").value;
    if (!(inputVal === "" || isNaN(inputVal))){
        let xml = new XMLHttpRequest();
        xml.onreadystatechange = function() {
            if (this.status === 200 && this.readyState === 4) {
                // Success, print message to the information div
                document.getElementById("updateStatus").innerHTML = this.responseText;
                // Automatically clear the field in 3s to view place holder
                document.getElementById("stuIDInput").value = "";
                setTimeout((e) => {
                    document.getElementById("updateStatus").innerHTML = "";
                }, 3000);
            }
        }
        // Construct the string to send as input (concatenating the student number)
        sendString = "requestUpdate=" + inputVal;
        // Call our set_needs_update endpoint
        xml.open("POST", "set_needs_update.php");
        // We have to set the header since we don't have anything else controlling it
        xml.setRequestHeader("content-type", "application/x-www-form-urlencoded");
        // Send the payload with requestUpdate carrying student number
        xml.send(sendString);
    }
}

requestClearPresent = () => {
    // No validation necessary for this function since we assume
    // the teacher is not malicious
    let xml = new XMLHttpRequest();
    xml.onreadystatechange = function() {
        if (this.status === 200 && this.readyState === 4) {
            // Success, print the message to the information div
            document.getElementById("clearStatus").innerHTML = this.responseText;
            // Clear the information div after 3s 
            setTimeout((e) => {
                document.getElementById("clearStatus").innerHTML = "";
            }, 3000);
        }
    }
    // Call our clear_present_flag.php endpoint
    xml.open("POST", "clear_present_flag.php");
    // We have to set the header since we don't have anything else controlling it
    xml.setRequestHeader("content-type", "application/x-www-form-urlencoded");
    // Send the payload with requestClear
    xml.send("requestClear=true");
}

requestPresent = () => {
    // No validation for automatic table display
    // since we assume teacher is not malicious
    let xml = new XMLHttpRequest();
    xml.onreadystatechange = function () {
        if (this.status === 200 && this.readyState === 4) {
            // Success, thus build the table
            let body = tableHelper(["Student ID", "Name", "Photo"], JSON.parse(this.responseText));
            // Forever loop from init continues to update the table by calling this function
            // Set table to body generated by tableHelper
            document.getElementById("tablePresent").innerHTML = body;
        }
    }
    // Call our request_db_entries.php endpoint
    xml.open("POST", "request_db_entries.php");
    // We have to set the header since we don't have anything else controlling it
    xml.setRequestHeader("content-type", "application/x-www-form-urlencoded");
    // Send the payload with requestTable with present attribute
    xml.send("requestTable=present");
}

requestAll = () => {
    // No validation for automatic table display
    // since we assume teacher is not malicious
    let xml = new XMLHttpRequest();
    xml.onreadystatechange = function () {
        if (this.status === 200 && this.readyState === 4) {
            // Success, thus build the table
            let body = tableHelper(["Student ID", "Name"], JSON.parse(this.responseText));
            // Forever loop from init continues to update the table by calling this function
            // Set table to body generated by tableHelper
            document.getElementById("tableAll").innerHTML = body;
        }
    }
    // Call our request_db_entries.php endpoint
    xml.open("POST", "request_db_entries.php");
    // We have to set the header since we don't have anything else controlling it
    xml.setRequestHeader("content-type", "application/x-www-form-urlencoded");
    // Send the payload with requestTable with getAll attribute
    xml.send("requestTable=getAll");
}

requestUnclaimed = () => {
    // No validation for automatic table display
    // since we assume teacher is not malicious
    let xml = new XMLHttpRequest();
    xml.onreadystatechange = function () {
        if (this.status === 200 && this.readyState === 4) {
            // Success, thus build the table
            let body = tableHelper(["Unclaimed Secrets"], JSON.parse(this.responseText));
            // Forever loop from init continues to update the table by calling this function
            // Set table to body generated by tableHelper
            document.getElementById("tableUnclaimed").innerHTML = body;
        }
    }
    // Call our request_db_entries.php endpoint
    xml.open("POST", "request_db_entries.php");
    // We have to set the header since we don't have anything else controlling it
    xml.setRequestHeader("content-type", "application/x-www-form-urlencoded");
    // Send the payload with requestTable with unclaimed attribute
    xml.send("requestTable=unclaimed");
}


requestSetParameters= () =>{
    // Open new websocket to send information from parameter fields
    let ws = new WebSocket("ws://cpen291-16.ece.ubc.ca/ws/signal/client");
    ws.addEventListener ('open', (e) => {
        // Parameters stored in dictionary object with default values
        sendObj = {"angle": 2, "move":0.5, "max":120, "min": 60, "updated":true};

        // Fetch new parameter values from page
        newFreqValue = document.getElementById("user_frequency").value;
        newDistValue = document.getElementById("user_distance").value;

        // Update the parameter values in the object
        sendObj["angle"] = parseInt(newFreqValue);
        sendObj["move"] = parseInt(newDistValue);

        // Send package over the websocket as a JSON string
        ws.send(JSON.stringify(sendObj));

        // Close the socket as soon as package is sent to avoid consuming resources
        ws.close();
    });
}

/**
 * This helper takes in an array of headers, and a JSON
 * to create the table HTML elements. Must ensure that 
 * json.length == headers.length. Does not check malformity
 */
tableHelper = (headers, json) => {
    // Begin the body
    let body = "<table class='table table-striped'><thead><tr>";
    // Iterate through the headers and add them to the body
    for (let i = 0; i < headers.length; i++) {
        body += "<th scope='col'>" + headers[i] + "</th>";
    }
    // End the header
    body += "</tr></thead><tbody>";
    // Iterate through the returned rows and add them to the body
    for (let i = 0; i < json.length; i++) {
        body += "<tr>";
        for (let j = 0; j < json[i].length; j++) {
            body += "<td>";
            if (headers[j] === "Photo") {
                body += specialImageHandler(json[i][j]);
            } else {
                body += json[i][j];
            }
            body += "</td>";
        }
        body += "</tr>";
    }
    body += "</tbody>";
    body += "</table>";
    return body;
}

// If it's an image, we're going to add our special sauce hover functionality
specialImageHandler = (filename) => {
    return "<a>Hover<div class='imgContainer'><img src=/photos/" + filename
                    + "?></div></a>";
}